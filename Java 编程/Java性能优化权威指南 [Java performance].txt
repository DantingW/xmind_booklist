第1章　策略、方法和方法论　　
	1.1 　性能问题的现状　　
	1.2 　性能分析的两种方法：自顶向下和自底向上　　
		1.2.1 　自顶向下　　
		1.2.2 　自底向上　　
	1.3 　选择正确的平台并评估系统性能　　
		1.3.1 　选择正确的CPU架构　　
		1.3.2 　评估系统性能　　
	1.4 　参考资料　　
第2章　操作系统性能监控　　
	2.1 　定义　　
	2.2 　CPU使用率　　
		2.2.1 　监控CPU使用率：Windows　　
		2.2.2 　监控CPU使用率：Windows typeperf　　
		2.2.3 　监控CPU使用率：Linux　　
		2.2.4 　监控CPU使用率：Solaris　　
		2.2.5 　命令行监控CPU使用率：Linux和Solaris　　
	2.3 　CPU调度程序运行队列　　
		2.3.1 　监控CPU调度程序运行队列：Windows　　
		2.3.2 　监控CPU调度程序运行队列：Solaris　　
		2.3.3 　监控CPU调度程序运行队列：Linux　　
	2.4 　内存使用率　　
		2.4.1 　监控内存利用率：Windows　　
		2.4.2 　监控内存使用率：Solaris　　
		2.4.3 　监控内存使用率：Linux　　
		2.4.4 　监控锁竞争：Solaris　　
		2.4.5 　监控锁竞争：Linux　　
		2.4.6 　监控锁竞争：Windows　　
		2.4.7 　隔离竞争锁　　
		2.4.8 　监控抢占式上下文切换　　
		2.4.9 　监控线程迁移　　
	2.5 　网络I/O使用率　　
		2.5.1 　监控网络I/O使用率：Solaris　　
		2.5.2 　监控网络I/O使用率：Linux　　
		2.5.3 　监控网络I/O使用率：Windows　　
		2.5.4 　应用性能改进的考虑　　
	2.6 　磁盘I/O使用率　　
	2.7 　其他命令行工具　　
	2.8 　监控CPU使用率：SPARC T系列系统　　
	2.9 　参考资料　　
第3章　JVM概览　　
	3.1 　HotSpot VM的基本架构　　
	3.2 　HotSpot VM运行时　　
		3.2.1 　命令行选项　　
		3.2.2 　VM生命周期　　
		3.2.3 　VM类加载　　
		3.2.4 　字节码验证　　
		3.2.5 　类数据共享　　
		3.2.6 　解释器　　
		3.2.7 　异常处理　　
		3.2.8 　同步　　
		3.2.9 　线程管理　　
		3.2.10 　C++堆管理　　
		3.2.11 　Java本地接口　　
		3.2.12 　VM致命错误处理　　
	3.3 　HotSpot VM垃圾收集器　　
		3.3.1 　分代垃圾收集　　
		3.3.2 　新生代　　
		3.3.3 　快速内存分配　　
		3.3.4 　垃圾收集器　　
		3.3.5 　Serial收集器　　
		3.3.6 　Parallel收集器：吞吐量为先！　　
		3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　
		3.3.8　　Garbage-First收集器：CMS替代者　　
		3.3.9 　垃圾收集器比较　　
		3.3.10 　应用程序对垃圾收集器的影响　　
		3.3.11 　简单回顾收集器历史　　
	3.4 　HotSpot VM JIT编译器　　
		3.4.1 　类型继承关系分析　　
		3.4.2 　编译策略　　
		3.4.3 　逆优化　　
		3.4.4 　Client JIT编译器概览　　
		3.4.5 　Server JIT编译器概览　　
		3.4.6 　静态单赋值--程序依赖图　　
		3.4.7 　未来增强展望　　
	3.5 　HotSpot VM自适应调优　　
		3.5.1 　Java 1.4.2的默认值　　
		3.5.2 　Java 5自动优化的默认值　　
		3.5.3 　Java 6 Update 18更新后的默认优化值　　
		3.5.4 　自适应Java堆调整　　
		3.5.5 　超越自动优化　　
	3.6 　参考资料　　
第4章　JVM性能监控　　
	4.1 　定义　　
	4.2 　垃圾收集　　
		4.2.1 　重要的垃圾收集数据　　
		4.2.2 　垃圾收集报告　　
		4.2.3 　垃圾收集数据的离线分析　　
		4.2.4 　图形化工具　　
	4.3 　JIT编译器　　
	4.4 　类加载　　
	4.5 　Java应用监控　　
	4.6 　参考资料　　
第5章　Java应用性能分析　　
	5.1 　术语　　
		5.1.1 　通用性能分析术语　　
		5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　
		5.1.3 　NetBeans Profiler术语　　
	5.2 　Oracle Solaris Studio Performance Analyzer　　
		5.2.1 　支持平台　　
		5.2.2 　下载/安装Oracle Solaris Studio Performance Analyzer　　
		5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　
		5.2.4 　查看性能数据　　
		5.2.5 　数据表示　　
		5.2.6 　过滤性能数据　　
		5.2.7 　命令行工具er_print　　
	5.3 　NetBeans Profiler　　
		5.3.1 　支持平台　　
		5.3.2 　下载安装NetBeans Profiler　　
		5.3.3 　开始方法分析会话　　
		5.3.4 　Controls子面板　　
		5.3.5 　Status子面板　　
		5.3.6 　Profiling Results子面板　　
		5.3.7 　Saved Snapshots子面板　　
		5.3.8 　View子面板　　
		5.3.9 　Basic Telemetry子面板　　
		5.3.10 　查看动态结果　　
		5.3.11 　对结果进行快照　　
		5.3.12 　启动内存分析会话　　
		5.3.13 　查看实时结果　　
		5.3.14 　对结果进行快照　　
		5.3.15 　定位内存泄漏　　
		5.3.16 　分析堆转储　　
	5.4 　参考资料　　
第6章　Java应用性能分析技巧　　
	6.1 　性能优化机会　　
	6.2 　系统或内核态CPU使用　　
	6.3 　锁竞争　　
	6.4 　Volatile的使用　　
	6.5 　调整数据结构的大小　　
		6.5.1 　StringBuilder或StringBuffer大小的调整　　
		6.5.2 　Java Collection类大小调整　　
	6.6 　增加并行性　　
	6.7 　过高的CPU使用率　　
	6.8 　其他有用的分析提示　　
	6.9 　参考资料　　
第7章　JVM性能调优入门　　
	7.1 　方法　　
		7.1.1 　假设条件　　
		7.1.2 　测试基础设施需求　　
	7.2 　应用程序的系统需求　　
		7.2.1 　可用性　　
		7.2.2 　可管理性　　
		7.2.3 　吞吐量　　
		7.2.4 　延迟及响应性　　
		7.2.5 　内存占用　　
		7.2.6 　启动时间　　
	7.3 　对系统需求分级　　
	7.4 　选择JVM部署模式　　
		7.4.1 　单JVM部署模式　　
		7.4.2 　多JVM部署模式　　
		7.4.3 　通用建议　　
	7.5 　选择JVM运行模式　　
		7.5.1 　Client模式或Server模式　　
		7.5.2 　32位/64位 JVM　　
		7.5.3 　垃圾收集器　　
	7.6 　垃圾收集调优基础　　
		7.6.1 　性能属性　　
		7.6.2 　原则　　
		7.6.3 　命令行选项及GC日志　　
	7.7 　确定内存占用　　
		7.7.1 　约束　　
		7.7.2 　HotSpot VM堆的布局　　
		7.7.3 　堆大小调优着眼点　　
		7.7.4 　计算活跃数据大小　　
		7.7.5 　初始堆空间大小配置　　
		7.7.6 　其他考量因素　　
	7.8 　调优延迟/响应性　　
		7.8.1 　输入　　
		7.8.2 　优化新生代的大小　　
		7.8.3 　优化老年代的大小　　
		7.8.4 　为CMS调优延迟　　
		7.8.5 　Survivor空间介绍　　
		7.8.6 　解析晋升阈值　　
		7.8.7 　监控晋升阈值　　
		7.8.8 　调整Survivor空间的容量　　
		7.8.9 　显式的垃圾收集　　
		7.8.10 　并发永久代垃圾收集　　
		7.8.11 　调优CMS停顿时间　　
		7.8.12 　下一步　　
	7.9 　应用程序吞吐量调优　　
		7.9.1 　CMS吞吐量调优　　
		7.9.2 　Throughput收集器调优　　
		7.9.3 　Survivor空间调优　　
		7.9.4 　调优并行垃圾收集线程　　
		7.9.5 　在NUMA系统上部署　　
		7.9.6 　下一步　　
	7.10 　极端示例　　
	7.11 　其他性能命令行选项　　
		7.11.1 　实验性（最近最大）优化　　
		7.11.2 　逃逸分析　　
		7.11.3 　偏向锁　　
		7.11.4 　大页面支持　　
	7.12 　参考资料　　
第8章　Java应用的基准测试　　
	8.1 　基准测试所面临的挑战　　
		8.1.1 　基准测试的预热阶段　　
		8.1.2 　垃圾收集　　
		8.1.3 　使用Java Time接口　　
		8.1.4 　剔除无效代码　　
		8.1.5 　内联　　
		8.1.6 　逆优化　　
		8.1.7 　创建微基准测试的注意事项　　
	8.2 　实验设计　　
	8.3 　使用统计方法　　
		8.3.1 　计算均值　　
		8.3.2 　计算标准差　　
		8.3.3 　计算置信区间　　
		8.3.4 　使用假设测试　　
		8.3.5 　使用统计方法的注意事项　　
	8.4 　参考文献　　
	8.5 　参考资料　　
第9章　多层应用的基准测试　　
	9.1 　基准测试难题　　
	9.2 　企业级应用基准测试的考量　　
		9.2.1 　定义被测系统　　
		9.2.2 　制定微基准测试　　
		9.2.3 　定义用户交互模型　　
		9.2.4 　定义性能指标　　
		9.2.5 　扩展基准测试　　
		9.2.6 　用利特尔法则验证　　
		9.2.7 　思考时间　　
		9.2.8 　扩展性分析　　
		9.2.9 　运行基准测试　　
	9.3 　应用服务器监控　　
		9.3.1 　GlassFish监控　　
		9.3.2 　监控子系统　　
		9.3.3 　Solaris　　
		9.3.4 　Linux　　
		9.3.5 　Windows　　
		9.3.6 　外部系统的性能　　
		9.3.7 　磁盘I/O　　
		9.3.8 　监控和调优资源池　　
	9.4 　企业级应用性能分析　　
	9.5 　参考资料　　
第10章　Web应用的性能调优　　
	10.1 　Web应用的基准测试　　
	10.2 　Web容器的组件　　
		10.2.1 　HTTP连接器　　
		10.2.2 　Servlet引擎　　
	10.3 　Web容器的监控和性能调优　　
		10.3.1 　容器的开发和生产模式　　
		10.3.2 　安全管理器　　
		10.3.3 　JVM调优　　
		10.3.4 　HTTP服务和Web容器　　
		10.3.5 　HTTP监听器　　
	10.4 　最佳实践　　
		10.4.1 　Servlet和JSP最佳实践　　
		10.4.2 　内容缓存　　
		10.4.3 　会话持久化　　
		10.4.4 　HTTP服务器文件缓存　　
	10.5 　参考资料　　
第11章　Web Service的性能　　
	11.1 　XML的性能　　
		11.1.1 　XML处理的生命周期　　
		11.1.2 　解析/解编组　　
		11.1.3 　访问　　
		11.1.4 　修改　　
		11.1.5 　序列化/编组　　
	11.2 　验证　　
	11.3 　解析外部实体　　
	11.4 　XML文档的局部处理　　
	11.5 　选择合适的API　　
	11.6 　JAX-WS参考实现栈　　
	11.7 　Web Service基准测试　　
	11.8 　影响Web Service性能的因素　　
		11.8.1 　消息大小的影响　　
		11.8.2 　不同Schema类型的性能特征　　
		11.8.3 　终端服务器的实现　　
		11.8.4 　处理程序的性能　　
	11.9 　最佳性能实践　　
		11.9.1 　二进制负载的处理　　
		11.9.2 　处理XML文档　　
		11.9.3 　使用MTOM发送XML文档　　
		11.9.4 　使用Provider接口　　
		11.9.5 　快速信息集　　
		11.9.6 　HTTP压缩　　
		11.9.7 　Web Service客户端的性能　　
	11.10 　参考资料　　
第12章　Java持久化及Enterprise Java Bean的性能　　
	12.1 　EJB编程模型　　
	12.2 　Java持久化API及其参考实现　　
	12.3 　监控及调优EJB容器　　
		12.3.1 　线程池　　
		12.3.2 　Bean池和缓存　　
		12.3.3 　EclipseLink会话缓存　　
	12.4 　事务隔离级　　
	12.5 　Enterprise Java Bean的最佳实践　　
		12.5.1 　简要说明使用的EJB基准测试　　
		12.5.2 　EJB 2.1　　
		12.5.3 　EJB 3.0　　
	12.6 　Java持久化最佳实践　　
		12.6.1 　JPA查询语言中的查询　　
		12.6.2 　查询结果缓存　　
		12.6.3 　FetchType　　
		12.6.4 　连接池　　
		12.6.5 　批量更新　　
		12.6.6 　选择正确的数据库锁策略　　
		12.6.7 　不带事务的读取　　
		12.6.8 　继承　　
	12.7 　参考资料　　
附录A 　重要的HotSpot VM选项　　
附录B 　性能分析技巧示例源代码　　
B.1 　锁竞争实现1　　
B.2 　锁竞争实现2　　
B.3 　锁竞争实现3　　
B.4 　锁竞争实现4　　
B.5 　锁竞争实现5　　
B.6 　调整容量变化1　　
B.7 　调整容量变化2　　
B.8 　增加并发性的单线程实现　　
B.9 　增加并发性的多线程实现