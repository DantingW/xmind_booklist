第1章 深入Web请求过程	1
	1．1 B/S网络架构概述	2
	1．2 如何发起一个请求	4
	1．3 HTTP协议解析	6
		1．3．1 查看HTTP信息的工具	8
		1．3．2 浏览器缓存机制	9
	1．4 DNS域名解析	12
		1．4．1 DNS域名解析过程	12
		1．4．2 跟踪域名解析过程	15
		1．4．3 清除缓存的域名	18
		1．4．4 几种域名解析方式	19
	1．5 CDN工作机制	20
		1．5．1 CDN架构	20
		1．5．2 负载均衡	21
		1．5．3 CDN动态加速	24
	1．6 总结	25
第2章 深入分析Java I/O的工作机制	26
	2．1 Java的I/O类库的基本架构	26
		2．1．1 基于字节的I/O操作接口	27
		2．1．2 基于字符的I/O操作接口	28
		2．1．3 字节与字符的转化接口	29
	2．2 磁盘I/O工作机制	30
		2．2．1 几种访问文件的方式	30
		2．2．2 Java访问磁盘文件	34
		2．2．3 Java序列化技术	35
	2．3 网络I/O工作机制	37
		2．3．1 TCP状态转化	38
		2．3．2 影响网络传输的因素	40
		2．3．3 Java Socket的工作机制	40
		2．3．4 建立通信链路	41
		2．3．5 数据传输	42
	2．4 NIO的工作方式	42
		2．4．1 BIO带来的挑战	42
		2．4．2 NIO的工作机制	43
		2．4．3 Buffer的工作方式	46
		2．4．4 NIO的数据访问方式	48
	2．5 I/O调优	50
		2．5．1 磁盘I/O优化	50
		2．5．2 TCP网络参数调优	51
		2．5．3 网络I/O优化	53
	2．6 设计模式解析之适配器模式	57
		2．6．1 适配器模式的结构	57
		2．6．2 Java I/O中的适配器模式	58
	2．7 设计模式解析之装饰器模式	58
		2．7．1 装饰器模式的结构	59
		2．7．2 Java I/O中的装饰器模式	59
	2．8 适配器模式与装饰器模式的区别	60
	2．9 总结	60
第3章 深入分析Java Web中的中文编码问题	61
	3．1 几种常见的编码格式	61
		3．1．1 为什么要编码	61
		3．1．2 如何“翻译”	62
	3．2 在Java中需要编码的场景	64
		3．2．1 在I/O操作中存在的编码	64
		3．2．2 在内存操作中的编码	66
	3．3 在Java中如何编解码	67
		3．3．1 按照ISO-8859-1编码	69
		3．3．2 按照GB2312编码	70
		3．3．3 按照GBK编码	71
		3．3．4 按照UTF-16编码	71
		3．3．5 按照UTF-8编码	72
		3．3．6 UTF-8编码代码片段	72
		3．3．7 对几种编码格式的比较	74
	3．4 在Java Web中涉及的编解码	74
		3．4．1 URL的编解码	76
		3．4．2 HTTP Header的编解码	79
		3．4．3 POST表单的编解码	79
		3．4．4 HTTP BODY的编解码	80
	3．5 JS中的编码问题	81
		3．5．1 外部引入JS文件	81
		3．5．2 JS的URL编码	82
		3．5．3 其他需要编码的地方	84
	3．6 常见问题分析	84
		3．6．1 中文变成了看不懂的字符	84
		3．6．2 一个汉字变成一个问号	85
		3．6．3 一个汉字变成两个问号	85
		3．6．4 一种不正常的正确编码	86
	3．7 一种繁简转换的实现方式	87
	3．8 总结	88
第4章 Javac编译原理	89
	4．1 Javac是什么	90
	4．2 Javac编译器的基本结构	90
	4．3 Javac工作原理分析	92
		4．3．1 词法分析器	93
		4．3．2 语法分析器	100
		4．3．3 语义分析器	105
		4．3．4 代码生成器	115
	4．4 设计模式解析之访问者模式	118
		4．4．1 访问者模式的结构	119
		4．4．2 Javac中访问者模式的实现	120
	4．5 总结	121
第5章 深入class文件结构	122
	5．1 JVM指令集简介	122
		5．1．1 与类相关的指令	124
		5．1．2 方法的定义	125
		5．1．3 属性的定义	126
		5．1．4 其他指令集	127
	5．2 class文件头的表示形式	135
	5．3 常量池	139
		5．3．1 UTF8常量类型	142
		5．3．2 Fieldref、Methodref常量类型	143
		5．3．3 Class常量类型	143
		5．3．4 NameAndType常量类型	144
	5．4 类信息	144
	5．5 Fields和Methods定义	145
	5．6 类属性描述	149
	5．7 Javap生成的class文件结构	150
		5．7．1 LineNumberTable	152
		5．7．2 LocalVariableTable	153
	5．8 总结	155
第6章 深入分析ClassLoader工作机制	156
	6．1 ClassLoader类结构分析	157
	6．2 ClassLoader的等级加载机制	158
	6．3 如何加载class文件	161
		6．3．1 加载字节码到内存	161
		6．3．2 验证与解析	163
		6．3．3 初始化Class对象	163
	6．4 常见加载类错误分析	163
		6．4．1 ClassNotFoundException	163
		6．4．2 NoClassDefFoundError	164
		6．4．3 UnsatisfiedLinkError	165
		6．4．4 ClassCastException	166
		6．4．5 ExceptionInInitializerError	167
	6．5 常用的ClassLoader分析	168
	6．6 如何实现自己的ClassLoader	172
		6．6．1 加载自定义路径下的class文件	172
		6．6．2 加载自定义格式的class文件	174
	6．7 实现类的热部署	176
	6．8 Java应不应该动态加载类	178
	6．9 总结	179
第7章 JVM体系结构与工作方式	180
	7．1 JVM体系结构	180
		7．1．1 何谓JVM	180
		7．1．2 JVM体系结构详解	183
	7．2 JVM工作机制	185
		7．2．1 机器如何执行代码	185
		7．2．2 JVM为何选择基于栈的架构	186
		7．2．3 执行引擎的架构设计	187
		7．2．4 执行引擎的执行过程	188
		7．2．5 JVM方法调用栈	193
	7．3 总结	197
第8章 JVM内存管理	198
	8．1 物理内存与虚拟内存	199
	8．2 内核空间与用户空间	200
	8．3 在Java中哪些组件需要使用内存	201
		8．3．1 Java堆	201
		8．3．2 线程	201
		8．3．3 类和类加载器	202
		8．3．4 NIO	202
		8．3．5 JNI	203
	8．4 JVM内存结构	203
		8．4．1 PC寄存器	204
		8．4．2 Java栈	204
		8．4．3 堆	205
		8．4．4 方法区	205
		8．4．5 运行时常量池	206
		8．4．6 本地方法栈	206
	8．5 JVM内存分配策略	206
		8．5．1 通常的内存分配策略	207
		8．5．2 Java中的内存分配详解	207
	8．6 JVM内存回收策略	212
		8．6．1 静态内存分配和回收	212
		8．6．2 动态内存分配和回收	213
		8．6．3 如何检测垃圾	213
		8．6．4 基于分代的垃圾收集算法	215
	8．7 内存问题分析	224
		8．7．1 GC日志分析	224
		8．7．2 堆快照文件分析	227
		8．7．3 JVM Crash日志分析	227
	8．8 实例1	233
	8．9 实例2	235
	8．10 实例3	237
	8．11 总结	242

第9章 Servlet工作原理解析	243
	9．1 从Servlet容器说起	243
		9．1．1 Servlet容器的启动过程	244
		9．1．2 Web应用的初始化工作	247
	9．2 创建Servlet实例	249
		9．2．1 创建Servlet对象	250
		9．2．2 初始化Servlet	250
	9．3 Servlet体系结构	252
	9．4 Servlet如何工作	255
	9．5 Servlet中的Listener	257
	9．6 Filter如何工作	259
	9．7 Servlet中的url-pattern	261
	9．8 总结	262
第10章 深入理解Session与Cookie	263
	10．1 理解Cookie	264
		10．1．1 Cookie属性项	264
		10．1．2 Cookie如何工作	265
		10．1．3 使用Cookie的限制	268
	10．2 理解Session	269
		10．2．1 Session与Cookie	269
		10．2．2 Session如何工作	270
	10．3 Cookie安全问题	273
	10．4 分布式Session框架	274
		10．4．1 存在哪些问题	274
		10．4．2 可以解决哪些问题	275
		10．4．3 总体实现思路	275
	10．5 Cookie压缩	280
	10．6 表单重复提交问题	282
	10．7 多终端Session统一	283
	10．8 总结	285
第11章 Tomcat的系统架构与设计模式	286
	11．1 Tomcat总体设计	286
		11．1．1 Tomcat总体结构	287
		11．1．2 Connector组件	293
		11．1．3 Servlet容器Container	298
		11．1．4 Tomcat中的其他组件	309
	11．2 Tomcat中的设计模式	309
		11．2．1 门面设计模式	309
		11．2．2 观察者设计模式	311
		11．2．3 命令设计模式	313
		11．2．4 责任链设计模式	314
	11．3 总结	316
第12章 Jetty的工作原理解析	317
	12．1 Jetty的基本架构	317
		12．1．1 Jetty的基本架构简介	317
		12．1．2 Handler的体系结构	319
	12．2 Jetty的启动过程	320
	12．3 接受请求	321
		12．3．1 基于HTTP协议工作	321
		12．3．2 基于AJP工作	323
		12．3．3 基于NIO方式工作	326
	12．4 处理请求	327
	12．5 与JBoss集成	330
	12．6 与Tomcat的比较	331
		12．6．1 架构比较	331
		12．6．2 性能比较	332
		12．6．3 特性比较	332
	12．7 总结	333


第13章 Spring框架的设计理念与设计模式分析	334
	13．1 Spring的骨骼架构	334
		13．1．1 Spring的设计理念	335
		13．1．2 核心组件如何协同工作	336
	13．2 核心组件详解	337
		13．2．1 Bean组件	337
		13．2．2 Context组件	339
		13．2．3 Core组件	340
		13．2．4 Ioc容器如何工作	342
	13．3 Spring中AOP的特性详解	352
		13．3．1 动态代理的实现原理	352
		13．3．2 Spring AOP如何实现	355
	13．4 设计模式解析之代理模式	358
		13．4．1 代理模式原理	358
		13．4．2 Spring中代理模式的实现	358
	13．5 设计模式解析之策略模式	361
		13．5．1 策略模式原理	361
		13．5．2 Spring中策略模式的实现	362
	13．6 总结	362
第14章 Spring MVC工作机制与设计模式	364
	14．1 Spring MVC的总体设计	364
	14．2 Control设计	369
		14．2．1 HandlerMapping初始化	370
		14．2．2 HandlerAdapter初始化	372
		14．2．3 Control的调用逻辑	373
	14．3 Model设计	374
	14．4 View设计	375
	14．5 框架设计的思考	377
		14．5．1 为什么需要框架	377
		14．5．2 需要什么样的框架	377
		14．5．3 框架设计的原则	378
		14．5．4 “指航灯”	378
		14．5．5 最基本的原则	378
	14．6 设计模式解析之模板模式	379
		14．6．1 模板模式的结构	379
		14．6．2 Spring MVC中的模板模式示例	379
	14．7 总结	380
第15章 深入分析Ibatis框架之系统架构与映射原理	381
	15．1 Ibatis框架主要的类层次结构	381
	15．2 Ibatis框架的设计策略	382
	15．3 Ibatis框架的运行原理	384
	15．4 示例	386
	15．5 Ibatis对SQL语句的解析	388
	15．6 数据库字段映射到Java对象	389
	15．7 示例运行的结果	391
	15．8 设计模式解析之简单工厂模式	391
		15．8．1 简单工厂模式的实现原理	391
		15．8．2 在Ibatis中的简单工厂模式示例	392
	15．9 设计模式解析之工厂模式	393
		15．9．1 工厂模式的实现原理	393
		15．9．2 Ibatis中的工厂模式示例	394
	15．10 总结	395
第16章 Velocity工作原理解析	397
	16．1 Velocity总体架构	398
	16．2 JJTree渲染过程解析	401
		16．2．1 #set语法	405
		16．2．2 Velocity的方法调用	406
		16．2．3 #if、#elseif和#else语法	409
		16．2．4 #foreach语法	410
		16．2．5 #parse语法	412
	16．3 事件处理机制	413
	16．4 常用优化技巧	416
		16．4．1 减少树的总节点数量	416
		16．4．2 减少渲染耗时的节点数量	416
	16．5 与JSP比较	417
		16．5．1 JSP渲染机制	417
		16．5．2 Velocity与JSP	423
	16．6 设计模式解析之合成模式	423
		16．6．1 合成模式的结构	423
		16．6．2 Velocity中合成模式的实现	424
	16．7 设计模式解析之解释器模式	425
		16．7．1 解释器模式的结构	425
		16．7．2 Velocity中解释器模式的实现	426
	16．8 总结	426
第17章 Velocity优化实践	427
	17．1 现实存在的问题	427
	17．2 优化的理论基础	428
		17．2．1 程序语言的三角形结构	428
		17．2．2 数据结构减少抽象化	429
		17．2．3 简单的程序复杂化	429
		17．2．4 减少翻译的代价	430
		17．2．5 变的转化为不变	430
	17．3 一个高效的模板引擎的实现思路	430
		17．3．1 vm模板如何被编译	432
		17．3．2 方法调用的无反射优化	439
		17．3．3 将字符输出改成字节输出	442
	17．4 优化的成果	443
		17．4．1 将char转成byte	443
		17．4．2 无反射执行	444
	17．5 其他优化手段	445
	17．6 总结	445
第18章 大浏览量系统的静态化架构设计	446
	18．1 淘宝大浏览量商品详情系统简介	446
	18．2 系统面临哪些挑战	447
	18．3 淘宝前台系统的优化历程	449
	18．4 大浏览量系统的静态改造	449
		18．4．1 什么是静态化系统	449
		18．4．2 为什么要进行静态化架构设计	450
		18．4．3 如何改造动态系统	451
		18．4．4 几种静态化方案的设计及选择	453
		18．4．5 如何解决失效问题	458
		18．4．6 服务端静态化方案的演进：CDN化	459
	18．5 总结	462