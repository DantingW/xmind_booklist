第1章 概述
	1.1 错位的信任
	1.2 注入攻击
	1.3 敏感数据泄露
	1.4 效能泄露
	1.5 拒绝服务
	1.6 序列化
	1.7 并发性、可见性和内存
	1.8 最低权限原则
	1.9 安全管理器
	1.10 类装载器
	1.11 小结
第2章 输入验证和数据净化（IDS）规则风险评估概要
	2.1 IDS00-J净化穿越受信边界的非受信数据
	2.2 IDS01-J验证前标准化字符串
	2.3 IDS02-J在验证之前标准化路径名
	2.4 IDS03-J不要记录未经净化的用户输入
	2.5 IDS04-J限制传递给ZipInputStream的文件大小
	2.6 IDS05-J使用ASCII字符集的子集作为文件名和路径名
	2.7 IDS06-J从格式字符串中排除用户输入
	2.8 IDS07-J不要向Runtime.exec 方法传递非受信、未净化的数据
	2.9 IDS08-J净化传递给正则表达式的非受信数据
	2.10 DS09-J如果没有指定适当的locale，不要使用locale相关方法处理与locale相关的数据
	2.11 IDS10-J不要拆分两种数据结构中的字符串
	2.12 IDS11-J在验证前去掉非字符码点
	2.13 IDS12-J在不同的字符编码中无损转换字符串数据
	2.14 IDS13-J在文件或者网络I/O两端使用兼容的编码方式
第3章 声明和初始化（DCL）规则风险评估概要
	3.1 DCL00-J防止类的循环初始化
	3.2 DCL01-J不要重用Java标准库的已经公开的标识
	3.3 DCL02-J将所有增强for语句的循环变量声明为final类型
第4章 表达式（EXP）规则风险评估概要
	4.1 EXP00-J不要忽略方法的返回值
	4.2 EXP01-J不要解引用空指针
	4.3 EXP02-J使用两个参数的Arrays.equals方法来比较两个数组的内容
	4.4 EXP03-J不要用相等操作符来比较两个基础数据类型的值
	4.5 EXP04-J确保使用正确的类型来自动封装数值
	4.6 EXP05-J不要在一个表达式中对同一变量进行多次写入
	4.7 EXP06-J不要在断言中使用有副作用的表达式
第5章 数值类型与运算（NUM）规则风险评估概要
	5.1 NUM00-J检测和避免整数溢出
	5.2 NUM01-J不要对同一数据进行位运算和数学运算
	5.3 NUM02-J确保除法运算和模运算中的除数不为0
	5.4 NUM03-J使用可容纳无符号数据合法取值范围的整数类型
	5.5 NUM04-J不要使用浮点数进行精细计算
	5.6 NUM05-J不要使用非标准化数
	5.7 NUM06-J使用strictfp修饰符确保跨平台浮点运算的一致性
	5.8 NUM07-J不要尝试与NaN进行比较
	5.9 NUM08-J检查浮点输入特殊的数值
	5.10 NUM09-J不要使用浮点变量作为循环计数器
	5.11 NUM10-J不要从浮点字元构造BigDecimal对象
	5.12 NUM11-J不要比较或者审查以字符串表达的浮点数值
	5.13 NUM12-J确保将数值转换成较小类型时不会产生数据丢失或曲解
	5.14 NUM13-J转换基本整数类型至浮点类型时应避免精度损失
第6章 面向对象（OBJ）规则风险评估概要
	6.1 OBJ00-J只有受信子类能对具有不变性的类和方法进行扩展
	6.2 OBJ01-J声明数据成员为私有并提供可访问的封装器方法
	6.3 OBJ02-J当改变基类时，保存子类之间的依赖关系
	6.4 OBJ03-J在新代码中，不要混用具有泛型和非泛型的原始数据类型
	6.5 OBJ04-J为可变类提供复制功能，并通过此功能允许将实例传递给非受信代码
	6.6 OBJ05-J在返回引用之前，防御性复制私有的可变的类成员
	6.7 OBJ06-J对可变输入和可变的内部组件创建防御性复制
	6.8 OBJ07-J不允许敏感类复制其自身
	6.9 OBJ08-J不要在嵌套类中暴露外部类的私有字段
	6.10 OBJ09-J比较类而不是类名称
	6.11 OBJ10-J不要使用公有静态的非final变量
	6.12 OBJ11-J小心处理构造函数抛出异常的情况
第7章 方法（MET）规则风险评估概要
	7.1 MET00-J验证方法参数
	7.2 MET01-J不要使用断言验证方法参数
	7.3 MET02-J不要使用弃用的或过时的类和方法
	7.4 MET03-J进行安全检测的方法必须声明为private或final
	7.5 MET04-J不要增加被覆写方法和被隐藏方法的可访问性
	7.6 MET05-J确保构造函数不会调用可覆写的方法
	7.7 MET06-J不要在clone中调用可覆写的方法
	7.8 MET07-J不要定义类方法来隐藏基类或基类接口中声明的方法
	7.9 MET08-J确保比较等同的对象能得到相等的结果
	7.10 MET09-J定义了equlas方法的类必须定义hashCode方法
	7.11 MET10-J实现compareTo方法时遵守常规合约
	7.12 MET11-J确保比较中的关键码是不可变的
	7.13 MET12-J不要使用析构函数
第8章 异常行为（ERR）规则风险评估概要
	8.1 ERR00-J不要消除或忽略可检查的异常
	8.2 ERR01-J不能允许异常泄露敏感信息
	8.3 ERR02-J记录日志时应避免异常
	8.4 ERR03-J在方法失败时恢复对象先前的状态
	8.5 ERR04-J不要在finally程序段非正常退出
	8.6 ERR05-J不要在finally程序段中遗漏可检查异常
	8.7 ERR06-J不要抛出未声明的可检查异常
	8.8 ERR07-J不要抛出RuntimeException、Exception或Throwable
	8.9 ERR08-J不要捕捉NullPointerException或任何它的基类
	8.10 ERR09-J禁止非受信代码终止JVM
第9章 可见性和原子性（VNA）规则风险评估概要
	9.1 VNA00-J当需要读取共享基础数据类型变量时，需要保证其可见性
	9.2 VNA01-J保证对一个不可变对象的共享引用的可见性
	9.3 VNA02-J保证对于共享变量的组合操作是原子性的
	9.4 VNA03-J即使每一个方法都是相互独立并且是原子性的，也不要假设一组调用是原子性的
	9.5 VNA04-J保证串联在一起的方法调用是原子性的
	9.6 VNA05-J保证在读写64位的数值时的原子性
第10章 锁（LCK）规则风险评估概要
	10.1 LCK00-J通过私有final锁对象可以同步那些与非受信代码交互的类
	10.2 LCK01-J不要基于那些可能被重用的对象进行同步
	10.3 LCK02-J不要基于那些通过getClass返回的类对象来实现同步
	10.4 LCK03-J不要基于高层并发对象的内置锁来实现同步
	10.5 LCK04-J即使集合是可访问的，也不要基于集合视图使用同步
	10.6 LCK05-J对那些可以被非受信代码修改的静态字段，需要同步进入
	10.7 LCK06-J不要使用一个实例锁来保护共享静态数据
	10.8 LCK07-J使用相同的方式请求和释放锁来避免死锁
	10.9 LCK08-J在异常条件时，保证释放已经持有的锁
	10.10 LCK09-J不要执行那些持有锁时会阻塞的操作
	10.11 LCK10-J不要使用不正确形式的双重锁定检查惯用法
	10.12 LCK11-J当使用那些不能对锁策略进行承诺的类时，避免使用客户端锁定
第11章 线程API（THI）规则风险评估概要
	11.1 THI00-J不要调用Thread.run
	11.2 THI01-J不能调用ThreadGroup方法
	11.3 THI02-J通知所有等待中的线程而不是单一线程
	11.4 THI03-J始终在循环中调用wait和await方法
	11.5 THI04-J确保可以终止受阻线程
	11.6 THI05-J不要使用Thread.stop来终止线程
第12章 线程池（TPS）规则风险评估概要
	12.1 TPS00-J使用线程池处理流量突发以实现降低性能运行
	12.2 TPS01-J不要使用有限的线程池来执行相互依赖的任务
	12.3 TPS02-J确保提交至线程池的任务是可中断的
	12.4 TPS03-J确保线程池中正在执行的任务不会失败而不给出任何提示
	12.5 TPS04-J使用线程池时，确保ThreadLocal变量可以重新初始化
第13章 与线程安全相关的其他规则（TSM）规则风险评估概要
	13.1 TSM00-J不要使用非线程安全方法来覆写线程安全方法
	13.2 TSM01-J不要让this引用在创建对象时泄漏
	13.3 TSM02-J不要在初始化类时使用后台线程
	13.4 TSM03-J不要发布部分初始化的对象
第14章 输入输出（FIO）规则风险评估概要
	14.1 FIO00-J不要操作共享目录中的文件
	14.2 FIO01-J使用合适的访问权限创建文件
	14.3 FIO02-J发现并处理与文件相关的错误
	14.4 FIO03-J在终止前移除临时文件
	14.5 FIO04-J在不需要时关闭资源
	14.6 FIO05-J不要使用wrap或duplicate创建缓存，并将这些缓存暴露给非受信代码
	14.7 FIO06-J不能在一个单独的InputStream上创建多个缓存区封装器
	14.8 FIO07-J不要让外部进程阻塞输入和输出流
	14.9 FIO08-J对读取一个字符或者字节的方法，使用int类型的返回值
	14.10 FIO09-J不要使用write方法输出超过0～255的整数
	14.11 FIO10-J使用read方法保证填充一个数组
	14.12 FIO11-J不要将原始的二进制数据作为字符数据读入
	14.13 FIO12-J为小端数据的读写提供方法
	14.14 FIO13-J不要在受信边界之外记录敏感信息
	14.15 FIO14-J在程序终止时执行正确的清理动作
第15章 序列化（SER）规则风险评估概要
	15.1 SER00-J在类的演化过程中维护其序列化的兼容性
	15.2 SER01-J不要偏离序列化方法的正确签名
	15.3 SER02-J在将对象向信任边界之外发送时，需要签名并且封装敏感对象
	15.4 SER03-J不要序列化未经加密的敏感数据
	15.5 SER04-J不要允许序列化和反序列化绕过安全管理器
	15.6 SER05-J不要序列化内部类实例
	15.7 SER06-J在反序列化时，对私有的可变的组件进行防御性复制
	15.8 SER07-J不要对实现定义的不可变因素使用默认的序列化格式
	15.9 SER08-J在从拥有特性的环境中进行反序列化之前最小化特权
	15.10 SER09-J不要从readObject方法中调用可以被覆写的方法
	15.11 SER10-J在序列化时，避免出现内存和资源泄漏
	15.12 SER11-J防止覆盖外部化的对象
第16章 平台安全性（SEC）规则风险评估概要
	16.1 SEC00-J不要允许特权代码块越过受信边界泄露敏感信息
	16.2 SEC01-J不要在特权代码块中使用污染过的变量
	16.3 SEC02-J不要基于非受信源进行安全检查
	16.4 SEC03-J不要在允许非受信代码装载任意类之后装载受信类
	16.5 SEC04-J使用安全管理器检查来保护敏感操作
	16.6 SEC05-J不要使用反射来增加类、方法和字段的可访问性
	16.7 SEC06-J不要依赖于默认的由URLClassLoader和java.util.jar提供的自动化签名检查
	16.8 SEC07-J当编写一个自定义的类装载器时调用基类的getPermissions方法
	16.9 SEC08-J定义基于原生方法的封装器
第17章 运行环境（ENV）规则风险评估概要
	17.1 ENV00-J不要签名只执行非特权操作的代码
	17.2 ENV01-J将所有安全敏感的代码置于单独一个jar包中，并且在签名之后封装它
	17.3 ENV02-J不要信任环境变量的值
	17.4 ENV03-J不要赋予危险的权限组合
	17.5 ENV04-J不要关闭字节码验证功能
	17.6 ENV05-J不要部署一个被远程监视的应用
第18章 其他（MSC）规则风险评估概要
	18.1 MSC00-J在交换安全数据时使用SSLSocket而不是Socket
	18.2 MSC01-J不要使用空的无限循环
	18.3 MSC02-J生成强随机数
	18.4 MSC03-J不要硬编码敏感信息
	18.5 MSC04-J防止内存泄漏
	18.6 MSC05-J不要耗尽堆空间
	18.7 MSC06-J当一个遍历正在进行时，不要修改它对应的集合
	18.8 MSC07-J防止多次实例化单例对象
术语表
参考资源